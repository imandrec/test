<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camera + Floating 3D Object (QR-gated)</title>
  <style>
    html,body {margin:0;height:100%;background:#000;overflow:hidden}
    video {position:fixed;inset:0;width:100%;height:100%;object-fit:cover}
    canvas.webgl {position:fixed;inset:0;pointer-events:none}
    .badge {position:fixed;left:8px;bottom:8px;color:#0f0;font:12px/1.4 monospace;z-index:20;white-space:pre}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
</head>
<body>
  <video id="cam" autoplay playsinline webkit-playsinline muted></video>
  <div class="badge" id="log"></div>

  <script>
    const log = (m)=>{ const el=document.getElementById('log'); el.textContent = String(m); };

    // --- 1) Camera feed
    const camEl = document.getElementById('cam');
    (async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } }, audio: false
        });
        camEl.srcObject = stream;
      } catch (e) {
        alert('Camera error: ' + (e.name || '') + ' ' + (e.message || e));
        console.warn(e);
      }
    })();

    // --- 2) Three.js overlay (transparent)
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
    camera.position.z = 2;

    const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.domElement.className = "webgl";
    document.body.appendChild(renderer.domElement);

    // Object (torus) we'll show/hide based on QR proximity
    const torus = new THREE.Mesh(
      new THREE.TorusKnotGeometry(0.5, 0.15, 128, 32),
      new THREE.MeshStandardMaterial({ color: 0x00ffff, metalness: 0.6, roughness: 0.3 })
    );
    scene.add(torus);
    scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(1,1,1));
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    // Render loop
    let visible = false;
    function animate(){
      // Only animate if "visible"
      torus.visible = visible;
      if (visible) {
        torus.rotation.x += 0.01;
        torus.rotation.y += 0.015;
        torus.position.y = Math.sin(Date.now()*0.001)*0.1;
      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- 3) QR gating logic (no libs)
    // Configure which QR text to accept
    const REQUIRED_QR_TEXT = 'BRACELET123';   // <-- change this per item
    const AREA_NEAR_THRESHOLD = 0.06;         // 6% of video area => "close"
    const AREA_FAR_THRESHOLD  = 0.04;         // 4% => hysteresis to avoid flicker
    let smoothArea = 0;                       // EMA smoothing
    let lastSeenOK = 0;

    async function startQRLoop() {
      if (!('BarcodeDetector' in window)) {
        log('No BarcodeDetector; showing object (fallback).');
        visible = true;  // or set false if you prefer hidden when unsupported
        return;
      }

      const detector = new BarcodeDetector({ formats: ['qr_code'] });
      log('Scanning for QR…');

      const loop = async () => {
        try {
          // Some browsers let you pass the <video> directly
          const codes = await detector.detect(camEl);

          let show = false;
          let msg = 'No QR';

          if (codes && codes.length) {
            // Pick the best match (by area) that also matches the required text (if set)
            const vW = camEl.videoWidth || innerWidth;
            const vH = camEl.videoHeight || innerHeight;
            const frameArea = vW * vH;

            let best = null;
            for (const c of codes) {
              const txt = (c.rawValue || '').trim();
              const bb = c.boundingBox || {};
              const area = (bb.width || 0) * (bb.height || 0);
              if (!best || area > best.area) best = { txt, area, bb };
            }

            if (best) {
              // If you want to accept ANY QR, set REQUIRED_QR_TEXT = ''.
              const matches = !REQUIRED_QR_TEXT || best.txt === REQUIRED_QR_TEXT;
              const areaRatio = best.area / (frameArea || 1);
              // Smooth area to reduce flicker
              smoothArea = smoothArea * 0.8 + areaRatio * 0.2;

              const near = smoothArea >= AREA_NEAR_THRESHOLD;
              const far  = smoothArea <= AREA_FAR_THRESHOLD;

              // Hysteresis: once near, stay near until we fall below FAR threshold
              if (matches) {
                if (near) { show = true; lastSeenOK = Date.now(); }
                else if (!far && (Date.now() - lastSeenOK) < 800) { show = true; } // grace period
              }

              // Optional: scale the object based on distance proxy
              // (bigger QR area => closer => bigger torus)
              const scale = THREE.MathUtils.clamp(0.8 + smoothArea*6, 0.8, 2.2);
              torus.scale.set(scale, scale, scale);

              msg = `QR "${best.txt}" area ${(smoothArea*100).toFixed(1)}% → ${show?'NEAR':'FAR'}`;
            }
          }

          visible = show;
          log(msg);
        } catch (e) {
          // If detect() throws intermittently, keep last state
          console.warn(e);
        }
        requestAnimationFrame(loop);
      };
      loop();
    }

    // Start QR after the video actually has dimensions
    camEl.addEventListener('loadedmetadata', startQRLoop, { once:true });
  </script>
</body>
</html>
